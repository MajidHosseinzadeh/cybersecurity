
---

### **اسلاید 2: محرمانگی و جامعیت**
- **محرمانگی**: اطمینان از این‌که پیام تنها توسط گیرنده مجاز قابل خواندن است.
- **جامعیت**: اطمینان از این‌که پیام در حین انتقال تغییری نکرده است.

> توجه: صرفاً تضمین محرمانگی به معنای تضمین جامعیت نیست. مهاجم ممکن است پیام را تغییر دهد بدون این‌که بتواند محتوای آن را بخواند.

---

### **اسلاید 6: کدهای احراز اصالت پیام (MAC)**
**Message Authentication Code (MAC)**:
1. **هدف MAC**:
   - تأمین جامعیت پیام: تضمین می‌کند که پیام در طول انتقال تغییر نکرده است.
   - تأمین اصالت پیام: اطمینان از این‌که پیام از منبع معتبر ارسال شده است.

2. **مثال عملی**:
   - ارسال پیام از \( A \) به \( B \) همراه با برچسب MAC:
     ```
     MAC = H(Key || Message)
     ```
   - گیرنده پیام را دریافت کرده و برچسب را با استفاده از کلید مشترک تأیید می‌کند.

3. **مفاهیم اصلی**:
   - **Tampering**: دستکاری پیام توسط مهاجم.
   - **Tag**: برچسبی که به پیام اضافه می‌شود و نشان‌دهنده صحت آن است.

---

### **اسلاید 7 و 8: شکل کلی الگوریتم MAC**
الگوریتم MAC شامل دو بخش است:
1. **Mac Algorithm**:
   - یک پیام \( m \) و کلید \( k \) را دریافت می‌کند و یک برچسب \( t \) تولید می‌کند:
     ```
     t = Mac(k, m)
     ```
2. **Vrfy Algorithm**:
   - برای تأیید اعتبار پیام و برچسب:
     ```
     b = Vrfy(k, m, t)
     ```
   - خروجی \( b \): مقدار صحیح (True) یا نادرست (False).

> **نکته:** MAC به تنهایی محرمانگی پیام را تضمین نمی‌کند؛ باید همراه با رمزگذاری استفاده شود.

---

### **اسلاید 9: امنیت MAC**
- MAC زمانی امن است که مهاجم نتواند یک برچسب معتبر برای پیام دلخواه جعل کند.
- شرط امنیت:
  ```
  Mac(k, m) = t
  ```
  مهاجم بدون دسترسی به کلید \( k \) قادر به تولید \( t \) معتبر نیست.

---

### **اسلاید 10: حمله بازپخش (Replay Attack)**
- مهاجم یک پیام و برچسب آن را در گذشته شنود کرده و بعداً دوباره ارسال می‌کند.
- راه‌حل:
  - استفاده از **Time Stamp** یا **Sequence Number** برای جلوگیری از ارسال مجدد پیام.

**مثال**:
- پیام:
  ```
  seqN || m
  ```
  - گیرنده با بررسی شمارنده (seqN) می‌تواند از تکرار پیام جلوگیری کند.

---

### **اسلاید 12 و 13: CMAC**
**Cipher-based MAC (CMAC)**:
- مبتنی بر **رمزگذاری قالبی (CBC)**:
  - پیام به بلوک‌هایی تقسیم شده و به صورت زیر رمزگذاری می‌شود:
    ```
    C1 = Enc(K, M1)
    C2 = Enc(K, M2 ⊕ C1)
    ...
    Cn = Enc(K, Mn ⊕ Cn-1 ⊕ K1)
    Tag = MSBTlen(Cn)
    ```
- بلوک آخر در صورت نیاز **پد (Pad)** می‌شود.

---

### **اسلاید 14 تا 17: روش‌های رمزگذاری با احراز اصالت**
سه روش کلی برای ترکیب رمزگذاری و احراز اصالت وجود دارد:
1. **Encrypt-and-authenticate**:
   - رمزگذاری و سپس افزودن برچسب MAC.
   - ناامن و استفاده از آن توصیه نمی‌شود.
2. **Authenticate-then-encrypt**:
   - تولید MAC و سپس رمزگذاری پیام و برچسب.
   - ممکن است آسیب‌پذیری داشته باشد.
3. **Encrypt-then-authenticate**:
   - پیام رمزگذاری شده و سپس MAC تولید می‌شود.
   - امن‌ترین روش و توصیه شده برای استفاده عملی.

---

### **اسلاید 18 تا 21: CCM (Counter with CBC-MAC)**
**CCM** یک الگوریتم ترکیبی است که هم رمزگذاری و هم احراز اصالت پیام را به طور همزمان انجام می‌دهد:
1. پیام همراه با داده‌های اضافه (**Associated Data**) و Nonce پردازش می‌شود.
2. برچسب MAC تولید می‌شود:
   ```
   tag = Mac(k, nonce || plaintext || AssociatedData)
   ```
3. پیام رمزگذاری شده و همراه با برچسب ارسال می‌شود:
   ```
   Ciphertext = Enc(k, plaintext || tag)
   ```
4. گیرنده، برچسب را برای تأیید صحت پیام بررسی می‌کند.

---

### **جمع‌بندی**
MAC یک ابزار ضروری برای تضمین جامعیت و اصالت پیام است، اما به تنهایی محرمانگی را فراهم نمی‌کند. در سیستم‌های امن، MAC معمولاً با رمزگذاری ترکیب می‌شود تا هم جامعیت و هم محرمانگی پیام تأمین شود. الگوریتم‌هایی مانند HMAC و CMAC مثال‌هایی از کاربرد عملی MAC هستند. اگر سوالی در مورد جزئیات یا پیاده‌سازی دارید، می‌توانید مطرح کنید.