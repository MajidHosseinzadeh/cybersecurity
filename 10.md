
---

### **اسلاید 2: الگوریتم‌های رمزگذاری کلید عمومی**
رمزگذاری کلید عمومی (Public-Key Cryptography):
- از **دو کلید** متفاوت استفاده می‌کند:
  1. کلید عمومی (Public Key): برای رمزگذاری.
  2. کلید خصوصی (Private Key): برای رمزگشایی.
- این الگوریتم‌ها بر پایه مسائل ریاضی بسیار سخت (مانند تجزیه اعداد بزرگ) بنا شده‌اند که بدون داشتن اطلاعات خاص (مانند کلید خصوصی) غیرقابل حل هستند.

---

### **اسلاید 3: الگوریتم رمزگذاری RSA**
**RSA** یکی از معروف‌ترین و پرکاربردترین الگوریتم‌های رمزگذاری کلید عمومی است:
- سال 1977 توسط **رون ریوست (Ron Rivest)**، **آدی شامیر (Adi Shamir)** و **لن ادلمن (Len Adleman)** در MIT طراحی شد.
- پایه ریاضی آن بر اساس مسئله تجزیه اعداد صحیح به عوامل اول است.

---

### **اسلاید 4: مسئله تجزیه اعداد صحیح**
- تجزیه یک عدد مرکب \( n = p \times q \) (که \( p \) و \( q \) اعداد اول هستند) بسیار دشوار است.
- بهترین الگوریتم موجود: **الگوریتم GNFS (General Number Field Sieve)** با پیچیدگی:
  \[
  O\left(\exp\left( \frac{64}{9} \cdot (\ln n)^{1/3} \cdot (\ln \ln n)^{2/3} \right)\right)
  \]
- امنیت RSA به دشواری تجزیه \( n \) بستگی دارد.

---

### **الگوریتم توان رسانی نمایی (Modular Exponentiation Algorithm)**

الگوریتم توان رسانی نمایی (یا محاسبه مدولار سریع) به ما اجازه می‌دهد توان‌های بزرگ یک عدد را به صورت کارآمد و تحت یک پیمانه محاسبه کنیم:
\[
c = b^e \mod m
\]
- \( b \): پایه (Base).
- \( e \): توان (Exponent).
- \( m \): پیمانه (Modulo).

---

### **مشکل محاسبات مستقیم**
برای محاسبه \( b^e \mod m \)، محاسبه مستقیم \( b^e \) وقتی \( e \) بزرگ باشد، منجر به اعداد بسیار بزرگ می‌شود که ذخیره‌سازی و محاسبات آن سخت است. الگوریتم توان رسانی نمایی این مشکل را با کاهش توان‌ها در هر مرحله حل می‌کند.

---

### **روش محاسبه توان رسانی نمایی**
الگوریتم از تکنیکی به نام **توان رسانی به روش تقسیم و غلبه** استفاده می‌کند:
- توان \( e \) را به باینری تبدیل می‌کنیم.
- از **خواص توان‌ها** برای کاهش محاسبات استفاده می‌کنیم:
  \[
  b^{e_1 + e_2} \mod m = \left( b^{e_1} \cdot b^{e_2} \right) \mod m
  \]
- به جای محاسبه مستقیم، به صورت تدریجی توان‌ها را محاسبه کرده و در هر مرحله پیمانه می‌گیریم.

---

### **الگوریتم گام‌به‌گام (روش سریع توان رسانی)**
#### **ورودی‌ها:**
- \( b \): پایه.
- \( e \): توان.
- \( m \): پیمانه.

#### **مراحل:**
1. مقدار اولیه:
   - \( result = 1 \)
   - \( base = b \mod m \)

2. حلقه:
   - اگر توان \( e \) فرد باشد (\( e \% 2 == 1 \)):
     \[
     result = (result \cdot base) \mod m
     \]
   - پایه را به توان دو می‌رسانیم:
     \[
     base = (base \cdot base) \mod m
     \]
   - توان را به نصف کاهش می‌دهیم (\( e = e // 2 \)).

3. تکرار تا زمانی که \( e = 0 \).

#### **خروجی:**
- مقدار \( result \): مقدار \( b^e \mod m \).

---

### **پیاده‌سازی در پایتون**
```python
def modular_pow(base, exponent, modulus):
    if modulus == 1:
        return 0  # هر عدد مدول 1 برابر با 0 است

    result = 1
    base = base % modulus  # کاهش اولیه پایه
    while exponent > 0:
        # اگر توان فرد است
        if exponent % 2 == 1:
            result = (result * base) % modulus
        # به‌روز‌رسانی پایه و کاهش توان
        base = (base * base) % modulus
        exponent = exponent // 2
    return result
```

---

### **مثال عددی**
#### **مسئله:**
محاسبه \( 3^{13} \mod 7 \).

#### **مراحل:**
1. مقدار اولیه:
   - \( result = 1 \)
   - \( base = 3 \mod 7 = 3 \)
   - \( e = 13 \).

2. تبدیل توان به باینری:
   \[
   13_{10} = 1101_2
   \]

3. محاسبات:
   - \( e = 13 \) (فرد):
     \[
     result = (1 \cdot 3) \mod 7 = 3
     \]
     \[
     base = (3 \cdot 3) \mod 7 = 2
     \]
     \[
     e = 13 // 2 = 6
     \]

   - \( e = 6 \) (زوج):
     \[
     base = (2 \cdot 2) \mod 7 = 4
     \]
     \[
     e = 6 // 2 = 3
     \]

   - \( e = 3 \) (فرد):
     \[
     result = (3 \cdot 4) \mod 7 = 5
     \]
     \[
     base = (4 \cdot 4) \mod 7 = 2
     \]
     \[
     e = 3 // 2 = 1
     \]

   - \( e = 1 \) (فرد):
     \[
     result = (5 \cdot 2) \mod 7 = 3
     \]
     \[
     base = (2 \cdot 2) \mod 7 = 4
     \]
     \[
     e = 1 // 2 = 0
     \]

4. پاسخ نهایی:
   \[
   result = 3
   \]

---

### **ویژگی‌های الگوریتم**
1. **پیچیدگی زمانی:**
   - زمان اجرا \( O(\log e) \) است، زیرا توان \( e \) در هر مرحله به نصف کاهش می‌یابد.
2. **حافظه مورد نیاز:**
   - نیاز به ذخیره چند متغیر ساده دارد و از لحاظ حافظه کارآمد است.

---

### **کاربردهای الگوریتم توان رسانی نمایی**
1. **رمزنگاری RSA:**
   - این الگوریتم برای محاسبه رمزگذاری و رمزگشایی RSA استفاده می‌شود:
     \[
     C = m^e \mod n \quad \text{و} \quad m = C^d \mod n
     \]
2. **محاسبات مدولار در سیستم‌های رمزنگاری دیگر:**
   - مانند الگوریتم‌های DH و ECC.
3. **تست اول بودن اعداد:**
   - برای تست‌های احتمالاتی مانند تست میلر-رابین (Miller-Rabin Primality Test).

---

### **اسلاید 8: الگوریتم رمزگذاری RSA**
RSA شامل دو مرحله اصلی است:

#### **1. رمزگذاری**:
- پیام \( m \) را با استفاده از کلید عمومی \( PU = (e, n) \) رمزگذاری می‌کنیم:
  \[
  C = m^e \mod n
  \]

#### **2. رمزگشایی**:
- پیام رمز شده \( C \) را با استفاده از کلید خصوصی \( PR = (d, n) \) رمزگشایی می‌کنیم:
  \[
  m = C^d \mod n
  \]

---

### **توضیح کامل اسلاید ۸: الگوریتم رمزگذاری RSA**

الگوریتم RSA یکی از الگوریتم‌های رمزگذاری **نامتقارن** است که از دو کلید **عمومی** و **خصوصی** استفاده می‌کند. این اسلاید به مراحل رمزگذاری و رمزگشایی در RSA می‌پردازد. در ادامه، مراحل این الگوریتم با جزئیات و مثال توضیح داده شده است.

---

### **1. تعریف کلیدها در RSA**
- **کلید عمومی (Public Key):**
  - شامل دو مقدار است:
    1. \( e \): نمای عمومی (Exponent)
    2. \( n \): پیمانه (Modulus)
  - این کلید برای رمزگذاری استفاده می‌شود و می‌تواند عمومی منتشر شود.

- **کلید خصوصی (Private Key):**
  - شامل دو مقدار است:
    1. \( d \): نمای خصوصی (Private Exponent)
    2. \( n \): پیمانه (Modulus)
  - این کلید برای رمزگشایی استفاده می‌شود و باید محرمانه نگه داشته شود.

---

### **2. مراحل رمزگذاری در RSA**
برای رمزگذاری پیام \( m \) (که باید عددی در بازه \( 0 \leq m < n \) باشد):
\[
C = m^e \mod n
\]
- \( m \): پیام اصلی (Plaintext)
- \( C \): پیام رمز شده (Ciphertext)
- \( e \): نمای عمومی
- \( n \): پیمانه

---

### **3. مراحل رمزگشایی در RSA**
گیرنده، پیام رمز شده \( C \) را با استفاده از کلید خصوصی \( d \) و \( n \) رمزگشایی می‌کند:
\[
m = C^d \mod n
\]
- \( C \): پیام رمز شده
- \( m \): پیام اصلی بازیابی شده
- \( d \): نمای خصوصی
- \( n \): پیمانه

---

### **مثال عددی برای درک بهتر**

#### **مقادیر فرضی کلیدها:**
- دو عدد اول انتخاب می‌کنیم:
  - \( p = 11 \), \( q = 17 \)
- محاسبه پیمانه:
  \[
  n = p \times q = 11 \times 17 = 187
  \]
- محاسبه \( \phi(n) \) (تابع فی اویلر):
  \[
  \phi(n) = (p-1) \times (q-1) = (11-1) \times (17-1) = 10 \times 16 = 160
  \]
- انتخاب \( e \) (نمای عمومی):
  \[
  e = 7 \quad \text{(شرط: } 1 < e < \phi(n) \text{ و } \text{gcd}(e, \phi(n)) = 1\text{)}
  \]
- محاسبه \( d \) (وارون ضربی \( e \) به پیمانه \( \phi(n) \)):
  \[
  d = e^{-1} \mod \phi(n) \quad \text{(محاسبه با الگوریتم اقلیدس توسعه‌یافته)} \quad d = 23
  \]

#### **کلیدها:**
- کلید عمومی: \( PU = (e, n) = (7, 187) \)
- کلید خصوصی: \( PR = (d, n) = (23, 187) \)

---

#### **مرحله رمزگذاری:**
فرض کنید پیام اصلی \( m = 88 \) باشد:
\[
C = m^e \mod n = 88^7 \mod 187
\]
محاسبه:
1. \( 88^2 \mod 187 = 154 \)
2. \( 88^4 \mod 187 = 154^2 \mod 187 = 25 \)
3. \( 88^7 \mod 187 = 88 \cdot 88^2 \cdot 88^4 \mod 187 = 88 \cdot 154 \cdot 25 \mod 187 = 11 \)

پیام رمز شده:
\[
C = 11
\]

---

#### **مرحله رمزگشایی:**
گیرنده \( C = 11 \) را با کلید خصوصی رمزگشایی می‌کند:
\[
m = C^d \mod n = 11^{23} \mod 187
\]
محاسبه:
1. \( 11^2 \mod 187 = 121 \)
2. \( 11^4 \mod 187 = 121^2 \mod 187 = 55 \)
3. \( 11^8 \mod 187 = 55^2 \mod 187 = 33 \)
4. \( 11^{16} \mod 187 = 33^2 \mod 187 = 154 \)
5. \( 11^{23} \mod 187 = 11^7 \cdot 11^{16} \mod 187 = 11 \cdot 33 \cdot 154 \mod 187 = 88 \)

پیام اصلی:
\[
m = 88
\]

---

### **4. اهمیت الگوریتم RSA**
- **امنیت:** RSA امنیت خود را از سختی تجزیه عدد \( n = p \times q \) می‌گیرد. تا زمانی که این تجزیه سخت باقی بماند، RSA امن است.
- **کاربردها:**
  - ارتباطات امن (مانند HTTPS).
  - امضاهای دیجیتال.
  - انتقال کلیدهای متقارن.

---

### **اسلاید 9: مثالی از RSA**
#### مثال:
- انتخاب مقادیر:
  - \( n = 187 \)
  - \( e = 7 \)
  - \( d = 23 \)
- رمزگذاری پیام \( m = 88 \):
  \[
  C = 88^7 \mod 187 = 11
  \]
- رمزگشایی پیام رمز شده \( C = 11 \):
  \[
  m = 11^{23} \mod 187 = 88
  \]

---

### **اسلاید 11 و 12: مبانی ریاضی RSA و تابع فی اویلر**
#### **1. مجموعه اعداد مدولار (\( \mathbb{Z}_n \))**:
- \( \mathbb{Z}_n = \{0, 1, 2, ..., n-1\} \): تمام اعداد صحیح غیرمنفی کمتر از \( n \).

#### **2. تابع فی اویلر (\( \phi(n) \))**:
- تعداد اعدادی که نسبت به \( n \) اول هستند.
- فرمول:
  - اگر \( n = p \times q \) و \( p, q \) اعداد اول باشند:
    \[
    \phi(n) = (p-1)(q-1)
    \]

---

### **اسلاید 15 و 16: وارون ضربی به پیمانه**
#### **تعریف وارون ضربی**:
عدد \( x \) وارون ضربی \( a \) به پیمانه \( n \) است اگر:
\[
a \times x \equiv 1 \ (\text{mod} \ n)
\]
#### **محاسبه وارون ضربی**:
- از **الگوریتم توسعه یافته اقلیدس (Extended Euclidean Algorithm)** برای یافتن \( x \) استفاده می‌شود.

---

### **اسلاید 17: قضیه اویلر**
اگر \( a \) و \( n \) نسبت به هم اول باشند:
\[
a^{\phi(n)} \equiv 1 \ (\text{mod} \ n)
\]
این قضیه برای اثبات امنیت RSA استفاده می‌شود.

---

### **قضیه اویلر (Euler’s Theorem)**

---

### **تعریف قضیه اویلر**
قضیه اویلر در محاسبات مدولار و نظریه اعداد استفاده می‌شود و بیان می‌کند که:

**اگر \( a \) و \( n \) نسبت به هم اول باشند (یعنی \( \text{gcd}(a, n) = 1 \))، آنگاه:**
\[
a^{\phi(n)} \equiv 1 \ (\text{mod} \ n)
\]
- \( \phi(n) \): **تابع فی اویلر** که تعداد اعداد طبیعی کمتر از \( n \) و نسبت به \( n \) اول را نشان می‌دهد.
- \( \equiv \): بیان هم‌نهشتی (Congruence).

---

### **تابع فی اویلر \( \phi(n) \)**
تابع \( \phi(n) \) تعداد اعداد طبیعی کمتر از \( n \) است که با \( n \) نسبت به هم اول هستند.

#### **محاسبه \( \phi(n) \):**
1. اگر \( n \) عدد اول باشد:
   \[
   \phi(n) = n - 1
   \]
   چون همه اعداد کمتر از \( n \) نسبت به \( n \) اول هستند.

2. اگر \( n = p \times q \) باشد و \( p \) و \( q \) اعداد اول باشند:
   \[
   \phi(n) = (p - 1) \times (q - 1)
   \]

#### **مثال:**
- اگر \( n = 8 \):
  \[
  \phi(8) = \{1, 3, 5, 7\} = 4
  \]
- اگر \( n = 15 \) و \( n = 3 \times 5 \):
  \[
  \phi(15) = (3 - 1) \times (5 - 1) = 2 \times 4 = 8
  \]

---

### **اثبات قضیه اویلر (خلاصه)**
1. **پایه ریاضی:**
   - قضیه بر اساس گروه‌های ضربی مدولار \( \mathbb{Z}_n^* \) تعریف شده است، که اعضای آن اعداد نسبت به \( n \) اول هستند.

2. **گام‌های اثبات:**
   - گروه \( \mathbb{Z}_n^* \) دارای \( \phi(n) \) عضو است.
   - ضرب اعضای این گروه تحت مدول \( n \) خاصیت بسته دارد (باقی‌مانده‌ها در محدوده \( n \) باقی می‌مانند).
   - اثبات می‌شود که:
     \[
     a^{\phi(n)} \equiv 1 \ (\text{mod} \ n)
     \]

---

### **مثال‌هایی از قضیه اویلر**

#### **مثال ۱:**
اگر \( n = 14 \) و \( a = 11 \):
1. بررسی نسبت اول بودن: \( \text{gcd}(11, 14) = 1 \).
2. محاسبه \( \phi(14) \):
   \[
   \phi(14) = (2 - 1) \times (7 - 1) = 6
   \]
3. بررسی هم‌نهشتی:
   \[
   11^{\phi(14)} \equiv 11^6 \ (\text{mod} \ 14)
   \]
   محاسبه:
   \[
   11^6 = 1771561 \quad \text{و} \quad 1771561 \mod 14 = 1
   \]
   بنابراین:
   \[
   11^6 \equiv 1 \ (\text{mod} \ 14)
   \]

#### **مثال ۲:**
اگر \( n = 10 \) و \( a = 7 \):
1. بررسی نسبت اول بودن: \( \text{gcd}(7, 10) = 1 \).
2. محاسبه \( \phi(10) \):
   \[
   \phi(10) = (2 - 1) \times (5 - 1) = 4
   \]
3. بررسی هم‌نهشتی:
   \[
   7^{\phi(10)} \equiv 7^4 \ (\text{mod} \ 10)
   \]
   محاسبه:
   \[
   7^4 = 2401 \quad \text{و} \quad 2401 \mod 10 = 1
   \]
   بنابراین:
   \[
   7^4 \equiv 1 \ (\text{mod} \ 10)
   \]

---

### **کاربردهای قضیه اویلر**
1. **RSA**:
   - در الگوریتم RSA، این قضیه پایه ریاضی رمزگذاری و رمزگشایی است.
   - در RSA، \( \phi(n) \) برای محاسبه کلید خصوصی \( d \) استفاده می‌شود:
     \[
     e \cdot d \equiv 1 \ (\text{mod} \ \phi(n))
     \]

2. **محاسبات مدولار سریع**:
   - این قضیه کمک می‌کند که توان‌های بزرگ را با محاسبات ساده‌تر مدولار کاهش دهیم.

---

### **جمع‌بندی**
قضیه اویلر یکی از مفاهیم بنیادی در نظریه اعداد و رمزنگاری است که بیان می‌کند:
\[
a^{\phi(n)} \equiv 1 \ (\text{mod} \ n)
\]

---

### **اسلاید 19: تولید کلید RSA**
1. انتخاب دو عدد اول بزرگ \( p \) و \( q \).
2. محاسبه \( n = p \times q \) و \( \phi(n) = (p-1)(q-1) \).
3. انتخاب \( e \) به‌طوری‌که \( 1 < e < \phi(n) \) و \( \text{gcd}(e, \phi(n)) = 1 \).
4. محاسبه \( d \) که وارون ضربی \( e \) به پیمانه \( \phi(n) \) باشد:
   \[
   d = e^{-1} \mod \phi(n)
   \]
5. کلیدها:
   - کلید عمومی: \( PU = (e, n) \)
   - کلید خصوصی: \( PR = (d, n) \)

---

### **اسلاید 20: بررسی صحت رمزگشایی**
اثبات می‌شود که رمزگشایی یک پیام رمز شده، پیام اصلی را بازمی‌گرداند:
\[
C^d \mod n = (m^e)^d \mod n = m
\]
با استفاده از قضیه اویلر، درستی این فرایند تضمین می‌شود.

---

### **اسلاید 22: چالش امنیت RSA**
اگر \( n \) تجزیه شود (\( n = p \times q \)):
1. می‌توان \( \phi(n) \) را محاسبه کرد.
2. با استفاده از \( \phi(n) \) و \( e \)، \( d \) (کلید خصوصی) قابل محاسبه است.
3. بنابراین، امنیت RSA به سختی تجزیه \( n \) بستگی دارد.

---

### **جمع‌بندی**
- RSA الگوریتمی امن برای رمزگذاری کلید عمومی است که بر اساس سختی تجزیه اعداد بزرگ عمل می‌کند.
- این الگوریتم برای ارتباطات امن در اینترنت (مثل HTTPS) و امضاهای دیجیتال استفاده می‌شود.
- امنیت آن با انتخاب کلیدهای بزرگ‌تر و پیچیده‌تر تضمین می‌شود.
